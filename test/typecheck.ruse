struct Car {
    engine: int,
    wheel: int,
    // gear: &int,
}

func void_ret() {
    return 1 //~error: function .* should not return
}

func f() -> Car {
    return 0 //~error: return type mismatch
    if 1 {
      0
    } else if 2 {
      0
      1
    }
}

func g() -> int {
    return 98
}

func h(a: int, b: &int) -> int {
    return 1
}

func main() {
    // var decl and assignment
    var s: int
    s = 4
    var car: Car
    car = 3 //~error: cannot assign 'int' type to 'Car'
    var immut = 4
    immut = car //~error: cannot assign 'Car' type to 'int'

    // member access
    3.engine //~error: type 'int' is not a struct
    car.wing //~error: unknown field 'wing' in struct 'Car'
    car.engine
    car.engine = car //~error: cannot assign 'Car' type to 'int'

    // immutability check
    let c_imm: Car
    c_imm = car //~error: 'c_imm' is not declared as mutable
    c_imm.wheel = 3 //~error: 'c_imm' is not declared as mutable
    // *(c_imm.gear) = 4 //~error: 'gear' is not a mutable reference
    var c1: Car
    c1.wheel = 3

    // binary expressions
    3 + car //~error: incompatible.*binary.*'int'.*'Car'
    (3 + car).wheel //~error: incompatible.*binary.*'int'.*'Car'
    (car).wheel
    let pa: &int
    let pb: &int
    // pa < pb //~error: nah

    // function calls
    car = f()
    var i: int
    i = f() //~error: cannot assign 'Car'.*'int'
    f() + g() //~error: incompatible.*binary.*'Car'.*'int'
    f().engine
    f().engine = 3 //~error: cannot assign .* rvalue
    f().wing //~error: 'wing'.*not.*member.*'Car'
    h(3, 4) //~error: argument type mismatch
    void_ret()
    i = void_ret() //~error: cannot assign 'void' .* 'int'
    
    // paren expr
    (f()).engine
    i = 3 + 4

    // ref and deref
    {
        *i //~error: dereference.*'int'
        &24 //~error: take address of an rvalue
        &g() //~error: take address of an rvalue

        // mutable reference of an immutable variable
        let ii = 4
        let v = var &ii //~error: cannot borrow 'ii' as mutable because .* declared immutable
        struct Val {
            a: int
        }
        let val = Val {.a = 3}

        // TODO: 'a' -> 'val.a'
        let p = var &val.a //~error: cannot borrow 'a' as mutable because .* declared immutable

        // (*p).a //~error: 'p' is an immutable reference
        // (*m.a).b //~error: 'm.a' is an immutable reference

        var imm_ptr: &int
        imm_ptr = var &i
        *imm_ptr = 3 //~error: 'imm_ptr' is not a mutable reference
        *(imm_ptr) = 3 //~error: 'imm_ptr' is not a mutable reference
        *imm_ptr = car //~error: cannot assign 'Car' type to 'int'
        imm_ptr = &i
        let mut_ptr: var &int
        *mut_ptr = 3
        mut_ptr = var &i //~error: 'mut_ptr' is not declared as mutable
    }

    let pcar: &Car
    (*pcar).wheel
    *(pcar.wheel) //~error: '&Car' is not a struct

    // typecasting
    let i_to_char = [string](i)
    i_to_char = 3 //~error: cannot assign 'int' type to 'string'

    // other constructs that skip typeck
    #printf("hello, world\n")
}

struct NonCopy {
    a: var &int,
}

func copyable() {
    var i = 42
    let nc1 = NonCopy {.a = var &i}
    var nc2: NonCopy
    nc2 = nc1 //~error: cannot copy non-copyable type 'NonCopy'
    var nc3 = nc2 //~error: cannot copy non-copyable type 'NonCopy'
}
